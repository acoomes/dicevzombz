<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dice vs Zombies - Upgraded</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #1a202c; /* Dark gray-blue */
            color: #e2e8f0; /* Light gray */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 1rem;
            text-align: center;
            margin: 0; /* Added to ensure no default body margin */
        }
        .game-container {
            background-color: #2d3748; /* Darker gray-blue */
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3), 0 4px 6px -2px rgba(0, 0, 0, 0.15);
            width: 100%;
            max-width: 600px;
        }
        .stats-bar {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap; /* Allow wrapping for smaller screens */
            gap: 0.5rem; /* Add gap for wrapped items */
            margin-bottom: 1.5rem;
            font-size: 0.875rem; /* 14px */
        }
        .stats-bar span {
            background-color: #4a5568; /* Gray */
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
        }
        .dice-area {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-bottom: 1.5rem;
            min-height: 80px; /* Ensure space for dice */
        }
        .die {
            width: 60px;
            height: 60px;
            background-color: #e2e8f0; /* Light gray */
            color: #1a202c; /* Dark gray-blue */
            border: 2px solid #a0aec0; /* Medium gray */
            border-radius: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem; /* 32px */
            transition: transform 0.3s ease-out, background-color 0.3s, border-color 0.2s, box-shadow 0.2s;
        }
        .die.rolling {
            animation: roll 0.5s ease-out;
        }
        @keyframes roll {
            0% { transform: rotate(0deg) scale(1); }
            25% { transform: rotate(90deg) scale(1.2); }
            50% { transform: rotate(180deg) scale(1); }
            75% { transform: rotate(270deg) scale(1.2); }
            100% { transform: rotate(360deg) scale(1); }
        }

        .die.selectable { /* Style for dice when they can be clicked for re-roll */
            cursor: pointer;
            border-color: #63b3ed; /* Light blue border to indicate interactivity */
        }
        .die.selectable:hover {
            border-color: #f56565; /* Red border on hover */
        }
        .die.selected-for-reroll { /* Style for dice selected for re-roll */
            border: 3px solid #f56565; /* Prominent red border */
            box-shadow: 0 0 10px #f56565;
        }

        .zombie-icon { color: #f56565; /* Red */ }
        .attack-icon { color: #48bb78; /* Green */ }
        .defend-icon { color: #4299e1; /* Blue */ }
        .super-attack-icon { color: #ecc94b; /* Yellow */ }

        .control-button {
            background-color: #c53030; /* Red */
            color: white;
            font-family: 'Press Start 2P', cursive;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            border: none;
            font-size: 1rem; /* 16px */
            cursor: pointer;
            transition: background-color 0.2s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            margin-top: 1rem;
        }
        .control-button:hover {
            background-color: #9b2c2c; /* Darker Red */
        }
        .control-button:disabled {
            background-color: #718096; /* Gray for disabled */
            cursor: not-allowed;
        }
        .message-area {
            margin-top: 1.5rem;
            min-height: 70px; /* Increased height for more messages */
            font-size: 0.875rem; /* 14px */
            color: #cbd5e0; /* Lighter gray */
            background-color: rgba(0,0,0,0.2);
            padding: 0.75rem;
            border-radius: 0.5rem;
            line-height: 1.4;
        }
        .zombie-art-area {
            margin-top: 1.5rem;
            font-size: 1.5rem; /* 24px */
            min-height: 40px; /* Ensure space for zombie display */
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.25rem;
        }
        .game-title {
            font-size: 2rem; /* 32px */
            margin-bottom: 1rem;
            color: #f56565; /* Red */
            text-shadow: 2px 2px #000;
        }
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .modal.active {
            opacity: 1;
            visibility: visible;
        }
        .modal-content {
            background-color: #2d3748;
            padding: 2rem;
            border-radius: 1rem;
            text-align: center;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
        }
        .modal-title {
            font-size: 1.75rem; /* 28px */
            margin-bottom: 1rem;
        }
        .modal-message {
            font-size: 1rem; /* 16px */
            margin-bottom: 1.5rem;
        }

        /* Mobile responsiveness */
        @media (max-width: 640px) {
            .game-container {
                padding: 1rem;
            }
            .stats-bar {
                font-size: 0.75rem; /* 12px */
                gap: 0.5rem; /* Maintained from base, good for wrapping */
                align-items: center; /* Good for wrapped items */
            }
            .stats-bar span {
                padding: 0.4rem 0.6rem; /* Slightly smaller padding */
            }
            .dice-area {
                gap: 0.5rem;
            }
            .die {
                width: 50px;
                height: 50px;
                font-size: 1.75rem; /* 28px */
            }
            .game-title {
                font-size: 1.5rem; /* 24px */
            }
            .control-button {
                font-size: 0.875rem; /* 14px */
                padding: 0.85rem 1.2rem; /* Increased vertical padding for better touch target */
            }
            .message-area {
                font-size: 0.75rem; /* 12px */
            }
            .zombie-art-area {
                font-size: 1.25rem; /* 20px */
            }
            .modal-content {
                padding: 1.5rem;
                width: 90%; /* Ensures modal doesn't touch screen edges */
            }
            .modal-title {
                font-size: 1.5rem; /* 24px */
            }
            .modal-message {
                font-size: 0.875rem; /* 14px */
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1 class="game-title">Dice vs Zombies</h1>

        <div class="stats-bar">
            <span id="round-display">Round: 1/10</span>
            <span id="zombies-display">Zombies: 10</span>
            <span id="barricade-display">Barricade: 20</span>
            <span id="reroll-display">Re-rolls: 1</span>
        </div>

        <div class="dice-area">
            <div class="die" id="die1">ðŸŽ²</div>
            <div class="die" id="die2">ðŸŽ²</div>
            <div class="die" id="die3">ðŸŽ²</div>
        </div>

        <button id="roll-button" class="control-button">Roll Dice!</button>

        <div class="message-area" id="message-area">
            Welcome, Survivor! Roll the dice to fight the horde.
        </div>

        <div class="zombie-art-area" id="zombie-art-area">
            </div>
    </div>

    <div id="game-over-modal" class="modal">
        <div class="modal-content">
            <h2 id="modal-title" class="modal-title">Game Over!</h2>
            <p id="modal-message" class="modal-message">The zombies have breached the barricade!</p>
            <button id="play-again-button" class="control-button">Play Again</button>
        </div>
    </div>

    <script>
        // Game Configuration
        const INITIAL_BARRICADE_STRENGTH = 20;
        const MAX_BARRICADE_STRENGTH = 30; // Max barricade can be repaired to
        const INITIAL_ZOMBIES = 10;
        const MAX_ROUNDS = 10;
        const NUM_DICE = 3;
        const OVERWHELMED_THRESHOLD = 15; // Zombies count above which they do bonus damage
        const OVERWHELMED_BONUS_DAMAGE = 5; // Bonus damage when overwhelmed

        // Dice Symbol Definitions
        const DICE_FACES = {
            1: { type: 'ZOMBIE_ADD', icon: 'ðŸ§Ÿ', text: 'New Zombie!', colorClass: 'zombie-icon' },
            2: { type: 'BARRICADE_BOOST', icon: 'ðŸ› ï¸', text: 'Barricade Boost!', colorClass: 'defend-icon' }, // Feature 2
            3: { type: 'ATTACK', icon: 'ðŸŽ¯', text: 'Attack!', colorClass: 'attack-icon' },
            4: { type: 'ATTACK', icon: 'ðŸŽ¯', text: 'Attack!', colorClass: 'attack-icon' },
            5: { type: 'DEFEND', icon: 'ðŸ›¡ï¸', text: 'Defend!', colorClass: 'defend-icon' },
            6: { type: 'SUPER_ATTACK', icon: 'ðŸ’¥', text: 'Super Attack!', colorClass: 'super-attack-icon' }
        };

        // Game State
        let gameState = {
            barricadeStrength: INITIAL_BARRICADE_STRENGTH,
            zombies: INITIAL_ZOMBIES,
            round: 1,
            gameOver: false,
            diceValues: [null, null, null], // Stores face objects of current roll
            rerollsAvailable: 1, // Feature 1: Re-rolls per round
            isRerollPhase: false, // Feature 1: True if player can select dice for re-roll
            diceSelectedForReroll: [false, false, false] // Feature 1
        };

        // DOM Elements
        const roundDisplay = document.getElementById('round-display');
        const zombiesDisplay = document.getElementById('zombies-display');
        const barricadeDisplay = document.getElementById('barricade-display');
        const rerollDisplay = document.getElementById('reroll-display'); // Feature 1
        const dieElements = [
            document.getElementById('die1'),
            document.getElementById('die2'),
            document.getElementById('die3')
        ];
        const rollButton = document.getElementById('roll-button');
        const messageArea = document.getElementById('message-area');
        const zombieArtArea = document.getElementById('zombie-art-area');
        const gameOverModal = document.getElementById('game-over-modal');
        const modalTitle = document.getElementById('modal-title');
        const modalMessage = document.getElementById('modal-message');
        const playAgainButton = document.getElementById('play-again-button');

        // --- Game Logic Functions ---

        /**
         * Initializes or resets the game to its starting state.
         */
        function initGame() {
            gameState.barricadeStrength = INITIAL_BARRICADE_STRENGTH;
            gameState.zombies = INITIAL_ZOMBIES;
            gameState.round = 1;
            gameState.gameOver = false;
            gameState.diceValues = [null, null, null];
            gameState.rerollsAvailable = 1; // Feature 1
            gameState.isRerollPhase = false; // Feature 1
            gameState.diceSelectedForReroll = [false, false, false]; // Feature 1
            
            updateDisplay();
            messageArea.textContent = "The night begins... Roll the dice to survive!";
            rollButton.textContent = "Roll Dice!";
            rollButton.disabled = false;
            gameOverModal.classList.remove('active');
            
            dieElements.forEach((die, index) => {
                die.textContent = 'ðŸŽ²';
                die.className = 'die'; // Reset classes
                // Remove any existing click listeners for safety. They are added in enableDieSelection.
                die.removeEventListener('click', onDieSelectClickHandler); 
            });
        }

        /**
         * Simulates rolling a single die.
         * @returns {number} A random number between 1 and 6.
         */
        function rollSingleDie() {
            return Math.floor(Math.random() * 6) + 1;
        }
        
        /**
         * Handles player clicking a die to select/deselect for re-roll.
         * @param {number} index - The index of the clicked die.
         */
        function handleDieClick(index) {
            if (!gameState.isRerollPhase || gameState.gameOver) return;

            gameState.diceSelectedForReroll[index] = !gameState.diceSelectedForReroll[index];
            dieElements[index].classList.toggle('selected-for-reroll', gameState.diceSelectedForReroll[index]);
        }

        /**
         * Sets up dice to be clickable for re-roll selection.
         */
        function enableDieSelection() {
            dieElements.forEach((dieEl, index) => {
                dieEl.classList.add('selectable');
                // Store index in a data attribute to retrieve in the event listener
                dieEl.dataset.dieIndex = index; 
                // Add event listener, ensuring it's not duplicated if called multiple times
                dieEl.removeEventListener('click', onDieSelectClickHandler); // Remove first to be safe
                dieEl.addEventListener('click', onDieSelectClickHandler);
            });
        }
        
        /**
         * Event handler for die click, calls handleDieClick with correct index.
         * This wrapper function is used to correctly pass the index to handleDieClick.
         */
        function onDieSelectClickHandler(event) {
            const dieIndex = parseInt(event.currentTarget.dataset.dieIndex);
            handleDieClick(dieIndex);
        }


        /**
         * Disables die selection and removes visual cues.
         */
        function disableDieSelection() {
            dieElements.forEach((dieEl, index) => {
                dieEl.classList.remove('selectable', 'selected-for-reroll');
                dieEl.removeEventListener('click', onDieSelectClickHandler);
                gameState.diceSelectedForReroll[index] = false; // Ensure selection state is reset
            });
        }

        /**
         * Handles the player's dice roll or re-roll action.
         */
        function handleRollDice() {
            if (gameState.gameOver) return;

            rollButton.disabled = true; // Disable button during roll/resolution
            let currentMessages = []; // Array to hold messages for this turn sequence

            if (gameState.isRerollPhase) { // This is a RE-ROLL action
                gameState.isRerollPhase = false; // Exit re-roll phase
                gameState.rerollsAvailable = 0; // Consume the re-roll
                updateDisplay(); // Update re-roll count display
                disableDieSelection(); // Make dice no longer selectable
                rollButton.textContent = "Rolling..."; // Indicate action

                let diceToAnimateCount = gameState.diceSelectedForReroll.filter(Boolean).length;
                let animatedDice = 0; // Counter for completed animations

                if (diceToAnimateCount === 0) { // Nothing selected for re-roll
                    currentMessages.push("No dice selected for re-roll. Proceeding with current results.");
                    resolveDiceEffects(currentMessages);
                    return;
                }
                currentMessages.push("Re-rolling selected dice...");

                gameState.diceValues.forEach((currentFace, index) => {
                    if (gameState.diceSelectedForReroll[index]) {
                        // This die is being re-rolled
                        dieElements[index].classList.add('rolling');
                        let rollCount = 0;
                        const animationInterval = setInterval(() => {
                            const randomFaceValue = rollSingleDie();
                            dieElements[index].textContent = DICE_FACES[randomFaceValue].icon;
                            dieElements[index].className = `die rolling ${DICE_FACES[randomFaceValue].colorClass}`;
                            rollCount++;
                            if (rollCount >= 5) { // Number of quick changes for animation
                                clearInterval(animationInterval);
                                const finalValue = rollSingleDie();
                                gameState.diceValues[index] = DICE_FACES[finalValue]; // Update the die value in game state
                                dieElements[index].textContent = gameState.diceValues[index].icon;
                                dieElements[index].className = `die ${gameState.diceValues[index].colorClass}`; // Set final color
                                dieElements[index].classList.remove('rolling');
                                
                                animatedDice++;
                                if (animatedDice === diceToAnimateCount) { // All selected dice re-rolled
                                    resolveDiceEffects(currentMessages);
                                }
                            }
                        }, 50); // Animation speed
                    }
                });

            } else { // This is the INITIAL ROLL of the round
                rollButton.textContent = "Rolling...";
                let diceAnimating = NUM_DICE; // Counter for dice still animating

                dieElements.forEach((dieEl, index) => {
                    dieEl.classList.add('rolling');
                    let rollCount = 0;
                    const animationInterval = setInterval(() => {
                        const randomFaceValue = rollSingleDie();
                        dieEl.textContent = DICE_FACES[randomFaceValue].icon;
                        dieEl.className = `die rolling ${DICE_FACES[randomFaceValue].colorClass}`;
                        rollCount++;
                        if (rollCount >= 5) {
                            clearInterval(animationInterval);
                            const finalValue = rollSingleDie();
                            gameState.diceValues[index] = DICE_FACES[finalValue];
                            dieEl.textContent = gameState.diceValues[index].icon;
                            dieEl.className = `die ${gameState.diceValues[index].colorClass}`;
                            dieEl.classList.remove('rolling');
                            
                            diceAnimating--;
                            if (diceAnimating === 0) { // All dice finished initial roll
                                if (gameState.rerollsAvailable > 0) {
                                    gameState.isRerollPhase = true;
                                    rollButton.textContent = "Re-roll Selected";
                                    rollButton.disabled = false; // Enable button for re-roll confirmation
                                    enableDieSelection(); // Allow player to click dice
                                    currentMessages.push("Initial roll complete. Select dice to re-roll, then click 'Re-roll Selected'.");
                                    messageArea.innerHTML = currentMessages.join('<br>');
                                } else {
                                    // No re-rolls available, proceed to resolve effects
                                    resolveDiceEffects(currentMessages);
                                }
                            }
                        }
                    }, 50);
                });
            }
        }
        
        /**
         * Resolves the effects of the rolled dice.
         * @param {string[]} initialMessages - Array of messages from earlier in the turn.
         */
        function resolveDiceEffects(initialMessages = []) {
            let currentMessages = [...initialMessages]; 
            if (currentMessages.length === 0 || (currentMessages.length > 0 && !currentMessages[currentMessages.length-1].includes("Resolving"))) {
                 if (gameState.rerollsAvailable === 0 && !gameState.isRerollPhase) { // Check if it was a re-roll phase that just ended
                    currentMessages.push("Re-roll complete. Resolving turn...");
                 } else {
                    currentMessages.push("Dice results locked in. Resolving turn...");
                 }
            }


            let newZombiesFromDice = 0;
            let defeatedByAttack = 0;
            let defeatedBySuperAttack = 0;
            let barricadeRepaired = 0;
            let barricadeBoosted = 0; // Feature 2: For BARRICADE_BOOST die face

            gameState.diceValues.forEach(face => {
                if (!face) return; // Should not happen if logic is correct
                currentMessages.push(`Rolled: ${face.icon} (${face.text})`);
                switch (face.type) {
                    case 'ZOMBIE_ADD':
                        newZombiesFromDice++;
                        break;
                    case 'ATTACK':
                        defeatedByAttack++;
                        break;
                    case 'SUPER_ATTACK':
                        defeatedBySuperAttack += 2; 
                        break;
                    case 'DEFEND':
                        barricadeRepaired++;
                        break;
                    case 'BARRICADE_BOOST': // Feature 2
                        barricadeBoosted += 3;
                        break;
                }
            });

            // Apply dice effects
            if (newZombiesFromDice > 0) {
                gameState.zombies += newZombiesFromDice;
                currentMessages.push(`${newZombiesFromDice} new zombie(s) attracted by the noise! ðŸ§Ÿ`);
            }
            
            const totalDefeated = defeatedByAttack + defeatedBySuperAttack;
            if (totalDefeated > 0) {
                const actualDefeated = Math.min(totalDefeated, gameState.zombies);
                gameState.zombies -= actualDefeated;
                currentMessages.push(`You fought back, defeating ${actualDefeated} zombie(s)! ðŸŽ¯`);
            }

            let totalRepaired = 0;
            if (barricadeRepaired > 0) {
                totalRepaired += barricadeRepaired;
                // Message for this is combined below if barricadeBoosted also occurs
            }
            if (barricadeBoosted > 0) { // Feature 2
                totalRepaired += barricadeBoosted;
            }

            if (totalRepaired > 0) {
                 gameState.barricadeStrength = Math.min(MAX_BARRICADE_STRENGTH, gameState.barricadeStrength + totalRepaired);
                 let repairMessage = "Barricade ";
                 if (barricadeBoosted > 0 && barricadeRepaired > 0) repairMessage += `repaired by ${barricadeRepaired} and boosted by ${barricadeBoosted}`;
                 else if (barricadeBoosted > 0) repairMessage += `significantly boosted by ${barricadeBoosted}`;
                 else if (barricadeRepaired > 0) repairMessage += `reinforced by ${barricadeRepaired}`;
                 repairMessage += `! Total +${totalRepaired}. ${barricadeBoosted > 0 ? 'ðŸ› ï¸' : 'ðŸ›¡ï¸'}`;
                 currentMessages.push(repairMessage);
            }
            
            updateDisplay(); // Update display after dice effects, before zombie attack
            
            // Short delay before zombie attack message for readability
            setTimeout(() => {
                zombiesAttack(currentMessages);
            }, 1000);
        }

        /**
         * Handles the zombie attack phase.
         * @param {string[]} currentMessages - Array to accumulate messages.
         */
        function zombiesAttack(currentMessages) {
            let damageTaken = gameState.zombies; // Base damage is number of zombies
            let overwhelmedMessage = "";

            if (gameState.zombies > 0) {
                // Feature 3: Overwhelmed mechanic
                if (gameState.zombies > OVERWHELMED_THRESHOLD) { 
                    damageTaken += OVERWHELMED_BONUS_DAMAGE;
                    overwhelmedMessage = ` The horde is OVERWHELMING! (+${OVERWHELMED_BONUS_DAMAGE} bonus damage)`;
                }
                gameState.barricadeStrength -= damageTaken;
                currentMessages.push(`The horde attacks! Barricade takes ${damageTaken} damage.${overwhelmedMessage} ðŸ’”`);
            } else {
                currentMessages.push("No zombies left to attack this round. A moment of peace!");
            }
            
            gameState.barricadeStrength = Math.max(0, gameState.barricadeStrength); // Prevent negative barricade

            messageArea.innerHTML = currentMessages.join('<br>'); // Display all messages for the turn
            updateDisplay();
            checkWinLoss(); // Check for game over conditions

            if (!gameState.gameOver) {
                gameState.round++;
                 // Reset for next round
                gameState.rerollsAvailable = 1; // Feature 1: Reset re-rolls for the new round
                gameState.isRerollPhase = false;
                // gameState.diceSelectedForReroll is reset by disableDieSelection or initGame
                disableDieSelection(); // Ensure dice are not selectable at start of new round

                if (gameState.round > MAX_ROUNDS && gameState.zombies > 0) {
                    // This condition (surviving max rounds with zombies left) is handled in checkWinLoss
                } else {
                     rollButton.textContent = "Roll Dice!"; // Reset button text
                     rollButton.disabled = false; // Re-enable for next round
                }
            }
             updateDisplay(); // Ensure reroll count and other stats are updated for the new round
        }

        /**
         * Updates all display elements on the page with current game state.
         */
        function updateDisplay() {
            roundDisplay.textContent = `Round: ${gameState.round}/${MAX_ROUNDS}`;
            zombiesDisplay.textContent = `Zombies: ${gameState.zombies}`;
            barricadeDisplay.textContent = `Barricade: ${gameState.barricadeStrength}`;
            rerollDisplay.textContent = `Re-rolls: ${gameState.rerollsAvailable}`; // Feature 1
            
            // Update zombie art
            zombieArtArea.innerHTML = ''; // Clear previous zombies
            const maxZombiesToShow = 20; // Limit display for performance/layout
            for (let i = 0; i < Math.min(gameState.zombies, maxZombiesToShow); i++) {
                const zombieSpan = document.createElement('span');
                zombieSpan.textContent = 'ðŸ§Ÿ';
                zombieArtArea.appendChild(zombieSpan);
            }
            if (gameState.zombies > maxZombiesToShow) {
                 const moreSpan = document.createElement('span');
                 moreSpan.textContent = ` +${gameState.zombies - maxZombiesToShow}`;
                 moreSpan.style.fontSize = '0.8em'; // Make the "+X" text slightly smaller
                 zombieArtArea.appendChild(moreSpan);
            }
        }

        /**
         * Checks for win or loss conditions.
         */
        function checkWinLoss() {
            let gameEndStatus = null; // To store the type of game end

            if (gameState.barricadeStrength <= 0) {
                gameEndStatus = "loss_barricade";
            } else if (gameState.zombies <= 0 && gameState.round <= MAX_ROUNDS) { // Win by eliminating all zombies
                gameEndStatus = "win_no_zombies";
            } else if (gameState.round > MAX_ROUNDS && gameState.barricadeStrength > 0) { 
                // Win by surviving all rounds, even if zombies remain
                gameEndStatus = "win_survived_rounds";
            }

            if (gameEndStatus && !gameState.gameOver) { // Process game end only once
                gameState.gameOver = true;
                rollButton.disabled = true;
                disableDieSelection(); // Ensure dice are not interactive post-game

                switch(gameEndStatus) {
                    case "loss_barricade":
                        modalTitle.textContent = "Game Over!";
                        modalMessage.textContent = "The zombies have breached the barricade! ðŸ’€";
                        messageArea.innerHTML += "<br><b>GAME OVER! The horde broke through!</b>";
                        break;
                    case "win_no_zombies":
                        modalTitle.textContent = "You Won!";
                        modalMessage.textContent = "You've defeated all the zombies! ðŸŽ‰";
                        messageArea.innerHTML += "<br><b>VICTORY! All zombies eliminated!</b>";
                        break;
                    case "win_survived_rounds":
                         modalTitle.textContent = "You Survived!";
                         modalMessage.textContent = `You made it through ${MAX_ROUNDS} rounds! The dawn is here! ðŸŒ…`;
                         messageArea.innerHTML += `<br><b>SURVIVED! You lasted ${MAX_ROUNDS} rounds!</b>`;
                         break;
                }
                gameOverModal.classList.add('active'); // Show the game over modal
            }
            updateDisplay(); // Final update for stats like round number if game ended by max rounds
        }

        // --- Event Listeners ---
        rollButton.addEventListener('click', handleRollDice);
        playAgainButton.addEventListener('click', initGame);

        // --- Initial Game Setup ---
        window.onload = function() {
            initGame();
        };
    </script>
</body>
</html>
